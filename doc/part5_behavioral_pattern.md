## 第五部分 行为模式

对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。

- 类的行为模式：使用继承关系在几个类之间分配行为
- 对象的行为模式：使用对象的聚合类分配行为



### 第三十四章 不变模式

一个对象的状态在对象被创建之后就不再变化。



#### 不变模式的结构和实现

**弱不变模式**

条件：

1. 所考虑的对象没有任何方法会修改对象的状态。
2. 所有的属性都应当是私有的。
3. 防止外界对象修改这个对象引用到的可变对象。

弱点：

1. 一个弱不变对象的子对象可以是可变对象。
2. 这个可变的子对象可能可以修改父对象的状态。



**强不变对象**

条件：

1. 所考虑的类所有的方法都应当时final
2. 这个类本身就是final的



**“只读”和“不变”的区别**

当一个变量是“只读”时，变量的值不能直接改变，但是可以再其他变量发生改变的时候发生改变。例如，一个人的出生年月日时“不变”属性，而一个人的年龄是“只读”属性。



#### 不变模式在Java语言中的应用

- String类
- 基本类型包装类



#### 不变模式的优缺点

优点：不变的对象更容易维护；并且一个不变的对象自动就是线程安全的，可以省掉处理同步化的开销。

缺点：在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建，再被Java语言的垃圾回收处理器收集走，这是一种资源的浪费。



#### 与享元模式的关系

享元模式以共享的方式支持大量的实例。享元模式中的享元对象可以是不变对象，实际上，大多数的享元对象时不变对象。



### 第三十五章 策略模式

针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以在不影响到客户端的情况下可以相互替换。



#### 策略模式的结构

![策略模式结构](img/策略模式结构.png)  

- 环境（Context）角色：持有一个Strategy类的引用。
- 抽象策略（Strategy）角色：给出所有具体策略类所需的接口。
- 具体策略（ConcreteStrategy）角色：包装了相关的算法或行为。

#### Java语言内部的例子

- AWT中的LayoutManager
- Swing中的Border

#### 什么情况下应当使用策略模式

1. 在一个系统中有许多类，他们之间的区别仅在与它们的行为。
2. 一个系统需要动态地在几种算法中选择一种。
3. 一个系统的算法使用的数据不可以让客户知道。
4. 一个对象有很多行为，如果不用恰当的模式，这些行为只好使用多重条件选择语句来实现。

#### 策略模式的优点和缺点

**优点**  

1. 提供了管理相关算法族的办法。
2. 提供了可以替换继承关系的办法。
3. 可以避免多条转移语句。

**缺点**

1. 客户端必须知道所有的策略类。
2. 策略模式会造成很多的策略类。

#### 与其他模式的关系

建造模式、适配器模式、享元模式、模板方法、MVC模式、装饰模式



### 第三十六章 模板方法模式

准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。

#### 模板方法的结构

![模板方法模式结构](img/模板方法模式结构.png)  

- 抽象模板角色：
  - 定义了一个或多个抽象操作，以便让子类实现。这些操作叫做基本操作，他们是一个顶级逻辑的组成步骤。
  - 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级的逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
- 具体模板角色：
  - 实现父类所定义的一个或多个抽象方法，他们是一个顶级逻辑的组成步骤。
  - 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现，从而导致顶级逻辑的实现各不相同。



#### 好莱坞原则

在好莱坞工作的演艺界人士都了解，在把简历递交给好莱坞的娱乐公司以后，所能做的事就是等待。这些公司会告诉他们“不要给我打电话，我们会给你打”。这便是所谓的“好莱坞原则”。好莱坞原则的关键之处是娱乐公司对娱乐项目的完全控制，这也体现了模板方法的关键：子类可以置换掉父类的可变部分，但是子类却不可以改表模板方法所代表的顶级逻辑。



#### Java语言中使用过的模板方法模式

- HttpServlet技术
- AbstractTableModel类
- AbstractListModel类



#### 模板方法模式中方法

**模板方法**  

一个模板方法是定义在抽象类中的，由子类不加修改地完全继承下来的，把基本方法组合在一起形成一个总算法或一个总行为的方法。

一个类中可以有任意多个模板方法，每个模板方法都可以调用任意多个具体方法。

**基本方法**  

- 抽象方法：一个抽象方法由抽象类声明，具体子类实现。Java中使用`abstract`标示出来。

- 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。

- 钩子方法：一个钩子方法有抽象类声明并实现，而子类会加以扩展。通常抽象给出一个空实现，作为方法的默认实现。命名应当以 do 开始。




### 第三十七章 Servlet技术中的模式

#### Servlet技术介绍

**Servlet的两个库包**  

- javax.Servlet：提供了普通的 Servlet 模型（用于TCP/IP之上的协议）
- javax.Servlet.http：这个库包提供了 HTTP 和 HTTPS 的 Servlet 模型。

**Servelt中主要的类**  

- Servlet接口
- GenericServlet类
- HttpServlet类

**HttpServlet的生命周期**  

1. 加载
2. 初始化
3. 就绪
4. 释放和湮灭

#### 模板方法的使用

- service方法是一个模板方法



#### 观察者模式的应用

- Servlet环境的事件
- Session的事件



### 第三十八章 观察者模式

又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式，源-监听器（Source/Linstener）模式或从属者（Dependents）模式。

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时来监听一个主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

#### 观察者模式的结构

![观察者模式结构](img/观察者模式结构.png)  

- 抽象主题（Subject）角色：主题角色把所有对观察者对象的引用抱在一个聚集（比如 Vector 对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
- 抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。
- 具体主题（ConcreteSubject）角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做被观察角色（Concrete Observable），通常用一个具体子类实现。
- 具体观察者（ConcreteObserver）角色：存储与主题的状态自恰的状态。具体抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。



#### 另一种实现方案

![观察者模式另一种实现](img/观察者模式第二种实现.png)  

可以采用抽象类实现抽象主题，将管理聚集的方法交由抽象主题，notifyObserver也可以移到抽象主题中。



#### Java对观察者模式的支持

- java.util.Observer接口
- java.util.Observable类



#### Java中的DEM事件机制

- AWT的DEM（Delegation Event Model）机制
- Servlet技术中的DEM机制
- SAX2技术中的DEM机制



#### 观察者模式的效果

**优点：**  

1. 观察者模式在被观察者和观察者之间建立一个抽象的耦合。
2. 观察者模式支持广播通信。

**缺点：**  

1. 如果一个被观察者对象有很多直接和间接的观察者的话，将所有观察者通知会花费很多时间。
2. 如果被观察者之间有循环依赖的话，被观察者会触发它们之间的循环调用，导致系统崩溃。
3. 如果对象观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递时以自洽的方式进行的。
4. 虽然观察者模式可以随时是观察者知道所观察的对象发生了变化，但观察者并不知道所观察对象是怎么发生变化的。

#### 与其他模式的关系

备忘录模式、MVC模式



### 第三十九章 专题：观察者模式与AWT中的事件处理

### 第四十章 专题：观察者模式与SAX2浏览器

### 第四十一章 专题：观察者模式与Swing定时器



### 第四十二章 专题：MVC模式与用户输入数据检查

#### 什么是MVC模式

MVC是一种架构模式，可以分解为：

- 合成模式
- 策略模式
- 观察者模式



#### 模式的种类

- 架构模式（Architectural pattern）：一个软件系统里的基本结构组织或纲要。
- 设计模式（Design Pattern）：一种提炼子系统或软件系统中的组件或者它们之间的关系纲要设计。
- 代码模式或成例（Coding Pattern 或 Idiom）：描述了怎样用一个特定的编程语言的特点来实现一个组件的某些特定的方面或关系。



#### MVC模式结构

![MVC](img/MVC.png)  

**模型端**  

模型是执行某些任务的代码，而这部分代码并没有任何逻辑觉得它对客户端的表示方法。

**多个视图端**  

一个模型端可以有几个视图端，而实际上复数的视图端是使用MVC的原始动机。

**多个控制器端**  

当用户端与相应的视图发生交互时，用户可以通过视窗更新模型的状态，这种更新是通过控制端进行的。



### 第四十三章 迭代器模式

迭代器模式又叫游标（Cursor）模式，可以实现顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。



#### 迭代器模式的结构

![迭代器模式](img/迭代器模式.png)  

- 抽象迭代器（Iterator）角色：定义出遍历元素所需的接口。
- 具体迭代器（ConcreteIterator）角色：实现了Iterator接口，并保持迭代过程中的游标位置。
- 聚集（Aggregate）角色：给出创建迭代器对象的接口。
- 具体聚集（ConcreteAggregate)角色：实现了创建迭代器的接口，返回一个具体迭代器实例。
- 客户端（Client）角色：持有对于聚集机器迭代器对象的引用，调用迭代器对象迭代接口，可能操作聚集元素的增加和删除。



#### 迭代器模式的优点和缺点

**优点**  

1. 简化了聚集的界面。
2. 每一个聚集对象都可以有一个或一个以上的迭代器对象，每一个迭代器对象时彼此独立的。
3. 遍历的算法封装在迭代器里面，迭代的算法可以独立于聚集角色变化。

**缺点**  

1. 迭代器给客户端一个聚集被顺序化的错觉。



#### 迭代器模式与其他模式的关系

合成模式、命令模式、备忘录模式、工厂方法模式



### 第四十四章 专题：Java对迭代子模式的支持

