## 第五部分 行为模式

对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。

- 类的行为模式：使用继承关系在几个类之间分配行为
- 对象的行为模式：使用对象的聚合类分配行为



### 第三十四章 不变模式

一个对象的状态在对象被创建之后就不再变化。



#### 不变模式的结构和实现

**弱不变模式**

条件：

1. 所考虑的对象没有任何方法会修改对象的状态。
2. 所有的属性都应当是私有的。
3. 防止外界对象修改这个对象引用到的可变对象。

弱点：

1. 一个弱不变对象的子对象可以是可变对象。
2. 这个可变的子对象可能可以修改父对象的状态。



**强不变对象**

条件：

1. 所考虑的类所有的方法都应当时final
2. 这个类本身就是final的



**“只读”和“不变”的区别**

当一个变量是“只读”时，变量的值不能直接改变，但是可以再其他变量发生改变的时候发生改变。例如，一个人的出生年月日时“不变”属性，而一个人的年龄是“只读”属性。



#### 不变模式在Java语言中的应用

- String类
- 基本类型包装类



#### 不变模式的优缺点

优点：不变的对象更容易维护；并且一个不变的对象自动就是线程安全的，可以省掉处理同步化的开销。

缺点：在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建，再被Java语言的垃圾回收处理器收集走，这是一种资源的浪费。



#### 与享元模式的关系

享元模式以共享的方式支持大量的实例。享元模式中的享元对象可以是不变对象，实际上，大多数的享元对象时不变对象。



### 第三十五章 策略模式

针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以在不影响到客户端的情况下可以相互替换。



#### 策略模式的结构

![策略模式结构](img/策略模式结构.png)  

- 环境（Context）角色：持有一个Strategy类的引用。
- 抽象策略（Strategy）角色：给出所有具体策略类所需的接口。
- 具体策略（ConcreteStrategy）角色：包装了相关的算法或行为。

#### Java语言内部的例子

- AWT中的LayoutManager
- Swing中的Border

#### 什么情况下应当使用策略模式

1. 在一个系统中有许多类，他们之间的区别仅在与它们的行为。
2. 一个系统需要动态地在几种算法中选择一种。
3. 一个系统的算法使用的数据不可以让客户知道。
4. 一个对象有很多行为，如果不用恰当的模式，这些行为只好使用多重条件选择语句来实现。

#### 策略模式的优点和缺点

**优点**  

1. 提供了管理相关算法族的办法。
2. 提供了可以替换继承关系的办法。
3. 可以避免多条转移语句。

**缺点**

1. 客户端必须知道所有的策略类。
2. 策略模式会造成很多的策略类。

#### 与其他模式的关系

建造模式、适配器模式、享元模式、模板方法、MVC模式、装饰模式


