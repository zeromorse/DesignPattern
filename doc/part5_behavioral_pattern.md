## 第五部分 行为模式

对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间的相互作用的。

- 类的行为模式：使用继承关系在几个类之间分配行为
- 对象的行为模式：使用对象的聚合类分配行为



### 第三十四章 不变模式

一个对象的状态在对象被创建之后就不再变化。



#### 不变模式的结构和实现

**弱不变模式**

条件：

1. 所考虑的对象没有任何方法会修改对象的状态。
2. 所有的属性都应当是私有的。
3. 防止外界对象修改这个对象引用到的可变对象。

弱点：

1. 一个弱不变对象的子对象可以是可变对象。
2. 这个可变的子对象可能可以修改父对象的状态。



**强不变对象**

条件：

1. 所考虑的类所有的方法都应当时final
2. 这个类本身就是final的



**“只读”和“不变”的区别**

当一个变量是“只读”时，变量的值不能直接改变，但是可以再其他变量发生改变的时候发生改变。例如，一个人的出生年月日时“不变”属性，而一个人的年龄是“只读”属性。



#### 不变模式在Java语言中的应用

- String类
- 基本类型包装类



#### 不变模式的优缺点

优点：不变的对象更容易维护；并且一个不变的对象自动就是线程安全的，可以省掉处理同步化的开销。

缺点：在需要频繁修改不变对象的环境里，会有大量的不变对象作为中间结果被创建，再被Java语言的垃圾回收处理器收集走，这是一种资源的浪费。



#### 与享元模式的关系

享元模式以共享的方式支持大量的实例。享元模式中的享元对象可以是不变对象，实际上，大多数的享元对象时不变对象。



### 第三十五章 策略模式

针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以在不影响到客户端的情况下可以相互替换。



#### 策略模式的结构

![策略模式结构](img/策略模式结构.png)  

- 环境（Context）角色：持有一个Strategy类的引用。
- 抽象策略（Strategy）角色：给出所有具体策略类所需的接口。
- 具体策略（ConcreteStrategy）角色：包装了相关的算法或行为。

#### Java语言内部的例子

- AWT中的LayoutManager
- Swing中的Border

#### 什么情况下应当使用策略模式

1. 在一个系统中有许多类，他们之间的区别仅在与它们的行为。
2. 一个系统需要动态地在几种算法中选择一种。
3. 一个系统的算法使用的数据不可以让客户知道。
4. 一个对象有很多行为，如果不用恰当的模式，这些行为只好使用多重条件选择语句来实现。

#### 策略模式的优点和缺点

**优点**  

1. 提供了管理相关算法族的办法。
2. 提供了可以替换继承关系的办法。
3. 可以避免多条转移语句。

**缺点**

1. 客户端必须知道所有的策略类。
2. 策略模式会造成很多的策略类。

#### 与其他模式的关系

建造模式、适配器模式、享元模式、模板方法、MVC模式、装饰模式



### 第三十六章 模板方法模式

准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。

#### 模板方法的结构

![模板方法模式结构](img/模板方法模式结构.png)  

- 抽象模板角色：
  - 定义了一个或多个抽象操作，以便让子类实现。这些操作叫做基本操作，他们是一个顶级逻辑的组成步骤。
  - 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级的逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
- 具体模板角色：
  - 实现父类所定义的一个或多个抽象方法，他们是一个顶级逻辑的组成步骤。
  - 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现，从而导致顶级逻辑的实现各不相同。



#### 好莱坞原则

在好莱坞工作的演艺界人士都了解，在把简历递交给好莱坞的娱乐公司以后，所能做的事就是等待。这些公司会告诉他们“不要给我打电话，我们会给你打”。这便是所谓的“好莱坞原则”。好莱坞原则的关键之处是娱乐公司对娱乐项目的完全控制，这也体现了模板方法的关键：子类可以置换掉父类的可变部分，但是子类却不可以改表模板方法所代表的顶级逻辑。



#### Java语言中使用过的模板方法模式

- HttpServlet技术
- AbstractTableModel类
- AbstractListModel类



#### 模板方法模式中方法

**模板方法**  

一个模板方法是定义在抽象类中的，由子类不加修改地完全继承下来的，把基本方法组合在一起形成一个总算法或一个总行为的方法。

一个类中可以有任意多个模板方法，每个模板方法都可以调用任意多个具体方法。

**基本方法**  

- 抽象方法：一个抽象方法由抽象类声明，具体子类实现。Java中使用`abstract`标示出来。

- 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。

- 钩子方法：一个钩子方法有抽象类声明并实现，而子类会加以扩展。通常抽象给出一个空实现，作为方法的默认实现。命名应当以 do 开始。




### 第三十七章 Servlet技术中的模式

#### Servlet技术介绍

**Servlet的两个库包**  

- javax.Servlet：提供了普通的 Servlet 模型（用于TCP/IP之上的协议）
- javax.Servlet.http：这个库包提供了 HTTP 和 HTTPS 的 Servlet 模型。

**Servelt中主要的类**  

- Servlet接口
- GenericServlet类
- HttpServlet类

**HttpServlet的生命周期**  

1. 加载
2. 初始化
3. 就绪
4. 释放和湮灭

#### 模板方法的使用

- service方法是一个模板方法



#### 观察者模式的应用

- Servlet环境的事件
- Session的事件



### 第三十八章 观察者模式

又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式，源-监听器（Source/Linstener）模式或从属者（Dependents）模式。

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时来监听一个主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

#### 观察者模式的结构

![观察者模式结构](img/观察者模式结构.png)  

- 抽象主题（Subject）角色：主题角色把所有对观察者对象的引用抱在一个聚集（比如 Vector 对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
- 抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。
- 具体主题（ConcreteSubject）角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做被观察角色（Concrete Observable），通常用一个具体子类实现。
- 具体观察者（ConcreteObserver）角色：存储与主题的状态自恰的状态。具体抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。



#### 另一种实现方案

![观察者模式另一种实现](img/观察者模式第二种实现.png)  

可以采用抽象类实现抽象主题，将管理聚集的方法交由抽象主题，notifyObserver也可以移到抽象主题中。



#### Java对观察者模式的支持

- java.util.Observer接口
- java.util.Observable类



#### Java中的DEM事件机制

- AWT的DEM（Delegation Event Model）机制
- Servlet技术中的DEM机制
- SAX2技术中的DEM机制



#### 观察者模式的效果

**优点：**  

1. 观察者模式在被观察者和观察者之间建立一个抽象的耦合。
2. 观察者模式支持广播通信。

**缺点：**  

1. 如果一个被观察者对象有很多直接和间接的观察者的话，将所有观察者通知会花费很多时间。
2. 如果被观察者之间有循环依赖的话，被观察者会触发它们之间的循环调用，导致系统崩溃。
3. 如果对象观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递时以自洽的方式进行的。
4. 虽然观察者模式可以随时是观察者知道所观察的对象发生了变化，但观察者并不知道所观察对象是怎么发生变化的。

#### 与其他模式的关系

备忘录模式、MVC模式



### 第三十九章 专题：观察者模式与AWT中的事件处理

### 第四十章 专题：观察者模式与SAX2浏览器

### 第四十一章 专题：观察者模式与Swing定时器



### 第四十二章 专题：MVC模式与用户输入数据检查

#### 什么是MVC模式

MVC是一种架构模式，可以分解为：

- 合成模式
- 策略模式
- 观察者模式



#### 模式的种类

- 架构模式（Architectural pattern）：一个软件系统里的基本结构组织或纲要。
- 设计模式（Design Pattern）：一种提炼子系统或软件系统中的组件或者它们之间的关系纲要设计。
- 代码模式或成例（Coding Pattern 或 Idiom）：描述了怎样用一个特定的编程语言的特点来实现一个组件的某些特定的方面或关系。



#### MVC模式结构

![MVC](img/MVC.png)  

**模型端**  

模型是执行某些任务的代码，而这部分代码并没有任何逻辑觉得它对客户端的表示方法。

**多个视图端**  

一个模型端可以有几个视图端，而实际上复数的视图端是使用MVC的原始动机。

**多个控制器端**  

当用户端与相应的视图发生交互时，用户可以通过视窗更新模型的状态，这种更新是通过控制端进行的。



### 第四十三章 迭代器模式

迭代器模式又叫游标（Cursor）模式，可以实现顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。



#### 迭代器模式的结构

![迭代器模式](img/迭代器模式.png)  

- 抽象迭代器（Iterator）角色：定义出遍历元素所需的接口。
- 具体迭代器（ConcreteIterator）角色：实现了Iterator接口，并保持迭代过程中的游标位置。
- 聚集（Aggregate）角色：给出创建迭代器对象的接口。
- 具体聚集（ConcreteAggregate)角色：实现了创建迭代器的接口，返回一个具体迭代器实例。
- 客户端（Client）角色：持有对于聚集机器迭代器对象的引用，调用迭代器对象迭代接口，可能操作聚集元素的增加和删除。



#### 迭代器模式的优点和缺点

**优点**  

1. 简化了聚集的界面。
2. 每一个聚集对象都可以有一个或一个以上的迭代器对象，每一个迭代器对象时彼此独立的。
3. 遍历的算法封装在迭代器里面，迭代的算法可以独立于聚集角色变化。

**缺点**  

1. 迭代器给客户端一个聚集被顺序化的错觉。



#### 迭代器模式与其他模式的关系

合成模式、命令模式、备忘录模式、工厂方法模式



### 第四十四章 专题：Java对迭代子模式的支持



### 第四十五章 责任链模式

很多对象由每一个对象及其对下家的引用而连接起来的一条链。请求在这个链上传递，直到这个链上的一个对象决定处理这个请求。发出这个请求的客户端并不知道实际是哪个对象最终处理了这个请求，这使得系统不在影响客户端的情况下动态地组织和分配责任。



#### 责任链模式的结构

![责任链模式](img/责任链模式.png)  



- 抽象处理者（Handler）角色：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。
- 具体处理者（ConcreteHandler）角色：具体处理者接到请求后，可以选择将请求处理掉或者传递给下家。由于具体处理者持有下家的引用，因此，如果有需要，处理者可以访问下家。



#### DHTML中的事件处理

浏览器的 DOM 模型中的事件处理均采用责任链模式。



#### 责任链模式与其他模式的关系

合成模式、命令模式、模板方法模式



### 第四十六章 专题：定时器与击鼓传花



### 第四十七章 命令模式

命令模式又称为行动模式或交易模式。它将一个请求或操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。



#### 命令模式结构

![命令模式](img/命令模式.png)  

- 客户（Client）角色：创建一个具体命令对象，并确定其接受者。
- 命令（Command）角色：声明了一个给所有具体命令类的抽象接口。
- 具体命令（ConcreteCommand)角色：定义一个接受者和行为之间的弱耦合；实现execute方法，负责调用接受者的相应操作。
- 请求者（Invoker）角色：负责调用命令对象执行请求，相关的方法叫做行动方法。
- 接受者（Receiver）角色：具体实施和执行一个请求。

#### 什么情况下应当使用命令模式

1. 使用命令模式作为Callback在面向对象系统中的替代。
2. 需要在不同的时间指定请求、将请求排队。
3. 系统支持命令的撤销。
4. 如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读会所有数据更新命令，重新调用execute方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。
5. 一个系统需要支持事务（transaction）。

#### 使用命令系统的优点和缺点

**优点**  

- 把请求一个操作的对象与知道怎么执行一个操作的对象分割开来。
- 命令类与其他任何别的类一样，可以修改和推广。
- 你可以把命令对象聚合在一起，合成为合成命令。
- 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。

**缺点**  

- 使用命令模式会导致某些系统有过多的具体命令类。

#### 命令模式与其他模式的关系

合成模式、备忘录模式、原型模式



### 第四十八章 专题：Swing库中的命令撤销和恢复



### 第四十九章 备忘录模式

又称为快照模式（Snapshot Pattern）或Token模式。备忘录对象是一个用来存储另外一个对象内部状态的快照对象。该模式用意是在不破换封装的条件下，将一个对象的状态捕捉住，并外部化存储起来，从而可以再将来合适的时候吧这个对象还原到存储起来的状态。常常与命令模式和迭代器模式一起使用。

#### 备忘录模式的结构

![备忘录模式的结构](img/备忘录模式的结构.png)  

- 备忘录（Memento）角色
  - 将发起人的内部状态存储起来。发起人通过**宽接口**读取数据，以便恢复发起人对象的内部状态。
  - 保护其内容不被发起人对象之外的任何对象所获取。负责人对象通过**窄接口**获取备忘录对象。
- 发起人（Originator）角色
  - 创建一个含有当前的内部状态的备忘录对象。
  - 使用备忘录对象存储其内部状态。
- 负责人（Caretaker）角色、
  - 负责保存备忘录对象。
  - 不检查备忘录对象的内容。

#### “白箱”备忘录模式的实现

![“白箱”备忘录模式的实现](img/“白箱”备忘录模式的实现.png)

#### 双重接口及其在Java语言中的实现

![双重接口的实现](img/双重接口的实现.png)

#### “黑箱”备忘录模式的实现

![“黑箱”备忘录模式的实现](img/“黑箱”备忘录模式的实现.png)

#### 备忘录模式与多重检查点

![备忘录模式与多重检查点](img/备忘录模式与多重检查点.png)

#### “自述历史”模式

#### “假如”协议模式

#### 备忘录模式与其他模式

命令模式、原始模型模式、迭代子模式

#### 备忘录模式的应用

- JDBC与数据库
- J2EE框架中备忘录模式的应用（Session）
- 浏览器的Cookie文件
- 系统配置文件

#### 备忘录模式的优缺点

**优点**  

- 有时一些发起人对象的内部信息必须保存在发起人以外的地方，但是必须要有发起人对象自己去取。
- 本模式简化了发起人类。
- 当发起人角色的状态改变的时候，有可能这个状态无效，这是就可以用存储起来的备忘录将状态复原。

**缺点**  

- 如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。
- 当负责人角色将一个备忘录角色存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。
- 当发起人角色状态改变的时候，有可能这个状态无效。




### 第五十章 状态模式

允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了的其他类一样。

#### 状态模式结构

![状态模式结构](img/状态模式结构.png)  

- 抽象状态（State）角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。
- 具体状态（ConcreteState）角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。
- 环境（Context）角色：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。

